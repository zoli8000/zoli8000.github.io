<html>
	<head>
		<style>
			.t {
				margin-top:-16px;
				margin-left:10px;
				pointer-events: none;
			}

			.item-input {
				grid-area: input;
			}
			.item-palette {
				grid-area: palette;
			}
			.item-code {
				grid-area: code;
			}
			.item-svg {
				grid-area: svg;
			}
			.item-decoder {
				grid-area: decoder;
			}
			
			.item-svgcode {
				grid-area: svgcode;
			}
			.container {
				display: grid;  
				row-gap: 40px;
				column-gap: 40px;
				grid-template-columns: 200px 200px 200px 200px;
				grid-template-rows: auto;
				grid-template-areas: 
					"input input palette palette"
					"input input code code"
					"svg decoder svgcode svgcode";
			}
		</style>

		<script>
			// Display coordinates for SVG image window.
			function showCoord(e) {
				let offset = svgDisp.getBoundingClientRect();
  				let relativeX = (e.pageX - offset.left);
				let relativeY = (e.pageY - offset.top);
				svgDispLabel.innerHTML = 'SVG ('+ (relativeX >> 1) +', '+ (relativeY >> 1) +')';
			}

			// Init, functions
			function init () {
				// SVG command list.
				svgCommands='_XCcSsQqTtAaZMmLlHhVvZz-';

				// Show decoder function, but remove comments and whitespaces

				decodeBox.value=decodeSVG.toString().replace(/\s*\/\/.*$|[\t\r\n]+/gm,'').replace("l=23","l="+svgCommands.length);
				
				// Example SVG codes
				fox = [' 89-lV/VP/I=/FF/9@/H`/^],!NTF 8:-R^/_]/MX,!OS<!ZQ< 8;!jU:!QT:![R:', 'fox #F90|white #FFF|black #000'];				
				cat = [' 9:-J="LBELOS/[G"V>L9J=,-="BLS/yG"~>9=, 9;!j`V 8<!jfD 89!\\a<!xa< 9:-ec/oc/jg, 98-cj"engnjh"mnnmpj','black #000|pink #FDD|cat #EEE|white #FFF']
				iteminp.value=readInput(cat);
				convert(iteminp.value)
			}
			
			convert = input => {
				colors={'none': [0, '#']};
				ev = function (str)  {
					if (str[0]!='<') return str;
					str = str.match(/[a-zA-Z]+/);
					return colors[str][1];
				}
				
				l = svgCommands.length;
				// 358 -> 116+405 without circles
				// 356 -> 

				// Calculate compressed string
				// Regex: 	m: 			full match
				//			$0:			color token + color code
				//			$coltok:	use color using token
				// 			$colval:	color value
				//			$com:		command found.
				//			$n:			number found.
				//			$bad:		error. When found, return empty string as a result.
				
				output = input.replace(/((?:\<)([a-zA-Z]+)( .+?)*(?:\>))|([a-zA-Z_-]+){1}|([0-9]+)|(.|\n)/g, 
										function (m, $0, $coltok, $colval, $com, $n, $bad) {
					// Color setting, set new color
					if ($0!=undefined) {						
						
						// Setting with color name
						if ($coltok in colors) {
							$n = colors[$coltok][0];
						// Setting with RGB code
						} else {
							n = Object.keys(colors).length;
							colors[$coltok]=[];
							$n = colors[$coltok][0] = n;
							colors[$coltok][1] = $colval.slice(1);							
						}
						colText=palette='';

						// Show colors used
						for (k of Object.keys(colors)) {
							palette += colors[k][1].toUpperCase();
							//colText +='"'+colors[k][1]+'" -- '+colors[k][0]+', '+k+'\n'; 
						}
						colBox.value=palette.slice(1);//+'\n'+colText;
					}
					
					// Wrong character, return with empty string
					if ($bad!=undefined) return '';

					// Command used, handle it
					if ($com!=undefined) {
						r='';
						for (i=0; i<$com.length; i++) {
							n = svgCommands.indexOf($com[i]);

							// Code not found - show '???'
							if (n==-1) return '???';

							// Commands are from chr(32)...
							r+= String.fromCharCode(n+32);
							}
						return r;
					}


					// Encode a number. n = 32 + (number of commands) + number
					n=32+l+Math.round($n,0);					
					return String.fromCharCode(n);

					// For larger numbers, split into two bytes. (Most probably won't be needed.)
					if (n>=124) {
						rem = n-124;
						hi = ~~(rem/96);
						lo = rem % 96;
						return String.fromCharCode(124+hi)+String.fromCharCode(32+lo);
					} else

					// For small numbers, return char(32 + (number of commands) + number)
					{
						
					}
					
					});
					
				// Set compressed result
				o.value=output;

				// Report compressed length
				codeLabel.innerHTML = 'Code ('+ output.length + ' + '+ (decodeBox.value).length+' = ' + (output.length + (decodeBox.value).length) + ' bytes)';
				
				// Uncompressed SVG creator
				C = []
				svgText = input.replace(/(_) *( *<.+?>| *[0-9]+) *(<.+?>| *[0-9]+)([^_X]*)/g, function (m, $com, $a, $b, $old) {
					if ($old.replace(/\s*/gm,'') != '') 
						return `<path stroke="${C[0]=ev($a)}" fill="${C[1]=ev($b)}" d="${$old}"/>\n`;
					else return '';
				});					
				// ToDo: handle colors. Invalid color codes, only uses the last block.
				svgText = svgText.replace(/^\s*X\s*(\d+)\s*(\d+)\s*(\d+)\s*$/gm, `<circle stroke="${C[0]}" fill="${C[1]}" cx=$1 cy=$2 r=$3/>`);
				svgBox.value=svgText;	
				svgLabel.innerHTML = 'SVG Code ('+svgText.length+' bytes)';

				// Try decompressing the SVG image, create a real, visible SVG from it.
				d = decodeSVG(colBox.value, output, l);
				s.innerHTML=d;								
				};

			// readInput
			function readInput(a) {
				// Inits
				let i = 0, txt = '', l=svgCommands.length; 
				
				// Color defs
				c=['none'].concat(a[1].split('|'));

				// Coded data
				let s=a[0].split``.map(function(_){return _.charCodeAt(0)-32}); 
				
				while (i<s.length) {					
					if (s[i]==0) txt += `\n\n_ <${c[s[++i]-l]}> <${c[s[++i]-l]}>`
					else if (s[i]<l) txt+= '\n'+svgCommands[s[i]];
					else txt += ` ${s[i]-l}`;
					i++;
				}
				return txt;
			}

			// Compact SVG decoder routine ~500bytes.
			function decodeSVG(p,coded,l=23){				
				// 	Slice colors			
				p=p.split`#`;

				// Color holder
				C=[];

				// Get numbers from coded string, starting from 0 (ascii code - 32)
				a=coded.split``.map(function(_){return _.charCodeAt(0)-32});
				
				// Start with empty string
				r="";				
			
				// f is a function, returning an url... for 
				f=function(_){return _>31?'"url(#c'+_+')"':'"#'+p[_]+'"'};
				
				// Color conversion - if '_' is used, get one color, otherwise use stored color
				m=x=>c?C[x]:C[x]=f(a[i++]-l);
				n=_=>(c=a[i++])-l+" ";

				// Loop through the string
				i=0;
				while (i<a.length){										
					// New SVG path					
					c=a[i++]
					if(c<2){
						// Workaround to draw circles						
						r+=`"/> <${["path","circle"][c]} stroke=${m(0)} fill=${m(1)}`;												
						r+=(c==0)?' d="':`cx=${n()} cy=${n()} r=`+n();									
						}
					else if(c<l) r+="_XCcSsQqTtAaZMmLlHhVvZz-"[c]; else r+=c-l+" ";
				}
				return r.slice(4).replace("[\]","\\\\")+'"/> '
			}

		</script>
	</head>
	<body id=b onload="init()">
		<p><br></p>

		<!-- Boxes for input and outputs -->
		<div class="container">		
			
			<!-- Input, you can edit this. -->
			<textarea class="item-input" oninput="convert(value)" rows=10 id=iteminp></textarea>		
			<span class="item-input t">Input</span>
			
			<!-- Generated SVG image -->
			<svg class="item-svg" viewBox="0 0 100 100" width="200px" height="200px" style="border: 1px solid black" onmousemove="showCoord(event)" id=svgDisp>
				<g id=s></g>
			</svg>		
			<span class="item-svg t" id=svgDispLabel>SVG</span>
			
			<!-- Generated compressed data -->
			<textarea class="item-code" rows=10 id=o></textarea>		
			<span class="item-code t" id=codeLabel>Code</span>
			
			<!-- Palette used -->
			<textarea class="item-palette" rows=10 id=colBox></textarea>
			<span class="item-palette t">Palette</span>
			
			<!-- Decoder: JavaScript code -->
			<textarea class="item-decoder" rows=10 id=decodeBox></textarea>		
			<span class="item-decoder t">Decoder</span>
			
			<!-- Uncompressed SVG generator code -->
			<textarea class="item-svgcode" rows=10 id=svgBox></textarea>		
			<span class="item-svgcode t" id=svgLabel>SVG Code</span>
		</div>
	</body>
</html>